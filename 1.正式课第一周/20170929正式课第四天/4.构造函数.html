<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//    function create(name,age) {
//        var obj ={};
//        obj.name = name;
//        obj.age = age;
//        obj.writeJs = function () {
//            console.log("我会写js啦")
//        }
//        return obj;
//    }
//    var person1 =create("王赛",18);
//    var person2 = create("黄天乐",22);
//    console.log(person1);
//    person1.writeJs()
// 构造函数；自定义类；
    function Create(name,age) {
        this.name = name;
        this.age = age;
        this.writeJs = function () {
            console.log("我会写js啦")
        }
    }
    // 函数被new ，那么这个函数就是一个类；
    // 判断当前函数是不是一个类，看当前函数有没有被new 过；
   // new + 类 ： 创建一个实例；
   // 类中的this指向当前的实例；
    var p2 = new Create("黄天乐",22);// undefined
    var p1 = new Create("王赛",18);
    console.log(p1.writeJs === p2.writeJs);// false
    // 构造函数模式和工厂模式的区别：
    // 1.相同点： 函数执行--》形成私有作用域-->形参赋值--> 预解释--> 代码从上到下执行；
    // 2.不同点：1. 类中不需要创建空对象，不需要return出这个对象。浏览器在执行时，会默认创建一个空对象，最后把它返回；
    // 2.类中的this指向当前的实例；

    // 所有类都是函数函数数据类型的，所有的实例都是对象数据类型的；

    // 函数既可以是一个普通的函数，又可以是一个类；

    // 类分为内置类，自定义类；

    // writeJs是每个实例的私有属性，所以不相等；

    var obj1 = {num:function () {

    }}
    var obj2 = {num : function () {

    }}
   console.log(obj1.num === obj2.num)


</script>
</body>
</html>